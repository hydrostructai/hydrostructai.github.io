<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShortCol - Tính toán Cột Lệch Tâm</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #f3f4f6; }
        .tab-active { border-bottom: 2px solid #2563eb; color: #2563eb; font-weight: 600; }
        .tab-inactive { color: #6b7280; }
        .tab-inactive:hover { color: #374151; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        /* Tùy chỉnh thanh cuộn cho bảng */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- 1. LOGIC BỐ TRÍ THÉP (VB6 converted) ---

        const generateRectLayoutEqual = (B, H, Cover, Nb, As) => {
            const width = B - 2 * Cover;
            const height = H - 2 * Cover;
            
            if (Nb < 4) Nb = 4;
            if (Nb % 2 !== 0) Nb += 1;

            // Tính số lượng thanh để rải đều
            let Nb1 = Math.floor(((width) * (Nb + 2) + 2 * (height)) / 2 / (H + B - 4 * Cover));
            if (Nb1 < 2) Nb1 = 2;
            
            let Nbot = Nb1;
            let Ntop = Nb1;
            let Nside = (Nb - Nbot - Ntop) / 2 + 2; 

            // Fallback an toàn
            if (!Number.isInteger(Nside) || Nside < 2) {
                 Nside = Math.floor((Nb - 4) / 2) + 2; 
                 // Điều chỉnh lại Ntop/Nbot nếu cần thiết để tổng = Nb
                 const remainder = Nb - 2 * (Nside - 2);
                 Nbot = Math.floor(remainder / 2);
                 Ntop = remainder - Nbot;
            }

            const bars = [];
            // Top & Bot bars
            for (let i = 0; i < Nbot; i++) {
                bars.push({ x: -width/2 + (width / (Math.max(Nbot - 1, 1))) * i, y: -height/2, As: As });
            }
            for (let i = 0; i < Ntop; i++) {
                bars.push({ x: -width/2 + (width / (Math.max(Ntop - 1, 1))) * i, y: height/2, As: As });
            }
            // Side bars (trừ 4 góc đã có)
            if (Nside > 2) {
                const sideSpacing = height / (Nside - 1);
                for (let i = 1; i < Nside - 1; i++) {
                    bars.push({ x: -width/2, y: -height/2 + sideSpacing * i, As: As });
                    bars.push({ x: width/2, y: -height/2 + sideSpacing * i, As: As });
                }
            }
            return bars;
        };

        const generateCircLayout = (D, Cover, Nb, As) => {
            const R_col = D / 2;
            const R_bars = R_col - Cover;
            const bars = [];
            if (Nb < 4) Nb = 4;
            const alpha = (2 * Math.PI) / Nb;

            for (let i = 0; i < Nb; i++) {
                const angle = alpha * i; // Bắt đầu từ 0 (phải), xoay ngược chiều kim đồng hồ
                bars.push({
                    x: R_bars * Math.cos(angle),
                    y: R_bars * Math.sin(angle),
                    As: As
                });
            }
            return bars;
        };

        // --- 2. CORE TÍNH TOÁN BIỂU ĐỒ TƯƠNG TÁC ---
        
        const calculateInteractionPoints = (type, B, H, D, fck, fyk, bars) => {
            const points = [];
            const Es = 200000; 
            const e_cu = 0.0035; // TCVN (thường là 0.0035 cho Bê tông thường)
            const Rb = fck; 
            const Rs = fyk; 

            const sectionDepth = type === 'rect' ? H : D;
            const steps = 60; // Tăng độ mịn

            // Tạo dãy giá trị chiều cao vùng nén c
            // Quét từ kéo thuần túy (c rất nhỏ âm) đến nén thuần túy (c rất lớn)
            // Tuy nhiên để vẽ chart P-M dương, ta tập trung vào vùng c > 0
            const c_values = [ -1e9, 0.01 ];
            for(let i=0.02; i<=1.3; i+=1.3/steps) {
                c_values.push(i * sectionDepth);
            }
            c_values.push(1e9);

            c_values.forEach(c => {
                let Nu = 0; // kN
                let Mu = 0; // kNm

                // --- Bê tông ---
                const beta1 = 0.8; 
                let a = beta1 * c; 
                
                // Giới hạn a trong tiết diện
                if (c < 0) a = 0;
                // Lưu ý: với khối ứng suất Whitney, a có thể > h, nhưng lực chỉ tính trong phần bê tông thực
                let a_eff = a;
                if (a_eff > sectionDepth) a_eff = sectionDepth;

                let Fc = 0, Mc = 0;

                if (type === 'rect') {
                    if (a_eff > 0) {
                        const Ac = B * a_eff;
                        Fc = Rb * Ac; 
                        const leverArm = (H / 2) - (a_eff / 2);
                        Mc = Fc * leverArm; 
                    }
                } else {
                    // Cột tròn: Tích phân dải
                    if (a_eff > 0) {
                        const R = D/2;
                        const numStrips = 50;
                        const dy = a_eff / numStrips;
                        let Ac_sum = 0, Mc_sum = 0;
                        const topY = R; // Đỉnh tiết diện

                        for(let j=0; j<numStrips; j++) {
                            const y_strip_center = topY - (j + 0.5) * dy;
                            // Kiểm tra y nằm trong đường tròn
                            if (y_strip_center < -R || y_strip_center > R) continue;
                            
                            const half_width = Math.sqrt(R*R - y_strip_center*y_strip_center);
                            const area_strip = 2 * half_width * dy;
                            
                            Ac_sum += area_strip;
                            Mc_sum += area_strip * y_strip_center;
                        }
                        Fc = Rb * Ac_sum;
                        Mc = Rb * Mc_sum;
                    }
                }

                // --- Cốt thép ---
                let Fs_total = 0, Ms_total = 0;
                bars.forEach(bar => {
                    const y_top = type === 'rect' ? H/2 : D/2;
                    const d_bar = y_top - bar.y; 
                    
                    let e_s = 0;
                    if (c >= 99999) e_s = e_cu; 
                    else if (c <= -99999) e_s = 10 * (Rs/Es); // Kéo lớn
                    else if (Math.abs(c) < 1e-3) e_s = -0.05; // Kéo rất lớn
                    else e_s = e_cu * (c - d_bar) / c;

                    let sigma_s = e_s * Es;
                    if (sigma_s > Rs) sigma_s = Rs;
                    if (sigma_s < -Rs) sigma_s = -Rs;

                    const Fs = sigma_s * bar.As; 
                    Fs_total += Fs;
                    Ms_total += Fs * bar.y; 
                });

                Nu = (Fc + Fs_total) / 1000; 
                Mu = (Mc + Ms_total) / 1000000; 

                // Chỉ lấy các điểm có Mu >= 0 để vẽ 1 bên (giả thiết đối xứng)
                // Hoặc giữ nguyên dấu để tổng quát
                points.push({ x: Mu, y: Nu });
            });
            
            // Lọc và sắp xếp lại để vẽ đường liền mạch
            // Với thuật toán trên, Mu thường tăng rồi giảm, Nu tăng dần.
            return points;
        };

        // --- 3. THUẬT TOÁN TÍNH HỆ SỐ AN TOÀN (RAY CASTING) ---
        const calculateSafetyFactorExact = (Pu, Mu, curvePoints) => {
            // 1. Xử lý các trường hợp đặc biệt
            const distLoad = Math.sqrt(Pu*Pu + Mu*Mu);
            if (distLoad < 1e-3) return 999; // Tải trọng tại gốc rất an toàn

            // 2. Chuẩn hóa về góc phần tư thứ nhất (Giả thiết đối xứng)
            // ShortCol thường so sánh trị tuyệt đối Momen
            const targetM = Math.abs(Mu);
            const targetP = Pu; 

            // 3. Tìm giao điểm của tia O->Load với các đoạn thẳng của biểu đồ
            // Tia Load: P = (targetP/targetM) * M
            // Đoạn thẳng Curve: P = P1 + t*(P2-P1), M = M1 + t*(M2-M1)
            
            let bestK = -1;

            for (let i = 0; i < curvePoints.length - 1; i++) {
                // Lấy 2 điểm liên tiếp trên biểu đồ
                const p1 = curvePoints[i];
                const p2 = curvePoints[i+1];

                // Chuyển về tọa độ tuyệt đối Momen để so sánh
                // (Vì biểu đồ có thể sinh ra phần âm nếu quét full c)
                // Tuy nhiên c_values ở trên chủ yếu sinh M dương.
                // Ta dùng giá trị thực tế từ curve để an toàn.
                const x1 = p1.x; // M
                const y1 = p1.y; // P
                const x2 = p2.x;
                const y2 = p2.y;

                // Bỏ qua các đoạn không hợp lệ (nhảy điểm quá xa hoặc nhiễu)
                
                // Giải hệ phương trình giao điểm:
                // k * targetM = x1 + t * (x2 - x1)
                // k * targetP = y1 + t * (y2 - y1)
                // Ẩn số: k (hệ số an toàn), t (tham số đoạn thẳng, 0 <= t <= 1)

                const dx = x2 - x1;
                const dy = y2 - y1;

                // Mẫu số (Định thức)
                // det = targetP * dx - targetM * dy (Công thức Cramer)
                // Hoặc dùng tích chéo vector chỉ phương
                const det = targetM * dy - targetP * dx;

                if (Math.abs(det) < 1e-9) continue; // Song song

                // Tính t
                // t = (targetM * y1 - targetP * x1) / (targetP * dx - targetM * dy)
                // Kiểm tra dấu mẫu số cẩn thận:
                // Hệ phương trình:
                // -t*dx + k*targetM = x1
                // -t*dy + k*targetP = y1
                // Det hệ = -dx*targetP - (-dy*targetM) = dy*targetM - dx*targetP
                
                const D_sys = dy * targetM - dx * targetP;
                if (Math.abs(D_sys) < 1e-9) continue;

                const D_t = y1 * targetM - x1 * targetP;
                const t = D_t / D_sys;

                if (t >= 0 && t <= 1.0001) {
                    // Tìm thấy giao điểm nằm trên đoạn thẳng
                    // Tính k
                    // k = (x1 + t*dx) / targetM (nếu targetM != 0)
                    // Hoặc k = (y1 + t*dy) / targetP
                    
                    let intersectX = x1 + t * dx;
                    let intersectY = y1 + t * dy;
                    
                    // Khoảng cách từ gốc đến giao điểm
                    const distCap = Math.sqrt(intersectX*intersectX + intersectY*intersectY);
                    
                    const k = distCap / distLoad;
                    
                    // Có thể có nhiều giao điểm (nếu biểu đồ lõm - hiếm gặp ở cột), lấy giao điểm xa nhất hoặc dương
                    // Với cột BTCT, lấy giá trị k dương đầu tiên hợp lý
                    if (k > 0) {
                        // Nếu tìm thấy nhiều giao điểm, thường lấy cái đầu tiên vì ta quét c liên tục
                        // Nhưng để chắc chắn, ta ưu tiên k lớn nhất? Không, tia từ gốc cắt vỏ bao tại 1 điểm duy nhất (convex).
                        bestK = k;
                        break; 
                    }
                }
            }

            if (bestK !== -1) return bestK.toFixed(3);
            return "N/A";
        };

        // --- COMPONENT APP ---

        const App = () => {
            const [activeTab, setActiveTab] = useState('input');
            const [colType, setColType] = useState('rect'); 
            
            const [material, setMaterial] = useState({ fck: 14.5, fyk: 280 });
            const [geometry, setGeometry] = useState({ B: 300, H: 400, D: 400, Cover: 30 });
            const [reinforcement, setReinforcement] = useState({ Nb: 6, d_bar: 18, As_bar: 254 });

            const [loads, setLoads] = useState([
                { id: 1, Pu: 500, Mu: 50, note: "TH1: Tĩnh + Hoạt" },
                { id: 2, Pu: 1200, Mu: 150, note: "TH2: Gió trái" }
            ]);

            const [barLayout, setBarLayout] = useState([]);
            const [interactionCurve, setInteractionCurve] = useState([]);
            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            useEffect(() => {
                let bars = [];
                const As = reinforcement.As_bar;
                if (colType === 'rect') {
                    bars = generateRectLayoutEqual(geometry.B, geometry.H, geometry.Cover, reinforcement.Nb, As);
                } else {
                    bars = generateCircLayout(geometry.D, geometry.Cover, reinforcement.Nb, As);
                }
                setBarLayout(bars);
            }, [colType, geometry, reinforcement]);

            useEffect(() => {
                if (barLayout.length === 0) return;
                const curve = calculateInteractionPoints(
                    colType, geometry.B, geometry.H, geometry.D, 
                    material.fck, material.fyk, barLayout
                );
                setInteractionCurve(curve);
            }, [barLayout, material]);

            useEffect(() => {
                if (!chartRef.current || interactionCurve.length === 0) return;
                if (chartInstance.current) chartInstance.current.destroy();

                // Lấy trị tuyệt đối Mu khi vẽ để đảm bảo nằm bên phải (Q1/Q4)
                const loadPoints = loads.map(l => ({ x: Math.abs(l.Mu), y: l.Pu, label: l.note }));
                
                // Vẽ đường gióng cho TẤT CẢ các điểm tải
                const safetyLines = [];
                loads.forEach(l => {
                    const k = calculateSafetyFactorExact(l.Pu, Math.abs(l.Mu), interactionCurve);
                    if (k !== "N/A" && !isNaN(k)) {
                        const valK = parseFloat(k);
                        // Điểm giao cắt trên biểu đồ (Capacity)
                        const CapX = Math.abs(l.Mu) * valK;
                        const CapY = l.Pu * valK;
                        
                        safetyLines.push({
                            label: 'Line',
                            data: [{x: 0, y: 0}, {x: CapX, y: CapY}], // Vẽ từ gốc đến biên chịu lực
                            borderColor: valK >= 1 ? 'rgba(34, 197, 94, 0.5)' : 'rgba(239, 68, 68, 0.5)', // Xanh nếu an toàn, đỏ nếu fail
                            borderDash: [4, 4],
                            borderWidth: 1,
                            pointRadius: 0,
                            showLine: true,
                            type: 'scatter',
                            order: 10
                        });
                    }
                });

                const ctx = chartRef.current.getContext('2d');
                chartInstance.current = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Biểu đồ tương tác (P-M)',
                                data: interactionCurve,
                                borderColor: 'rgb(37, 99, 235)',
                                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                                showLine: true,
                                pointRadius: 0,
                                fill: true,
                                tension: 0.2,
                                order: 2
                            },
                            {
                                label: 'Điểm tải trọng',
                                data: loadPoints,
                                backgroundColor: 'rgb(220, 38, 38)',
                                pointRadius: 6,
                                order: 1
                            },
                            ...safetyLines
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { labels: { filter: item => item.text !== 'Line' } },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => {
                                        if(ctx.dataset.label === 'Điểm tải trọng') {
                                            const l = loads[ctx.dataIndex];
                                            return `${l.note}: M=${Math.abs(l.Mu)}, P=${l.Pu}`;
                                        }
                                        return `M=${ctx.raw.x.toFixed(1)}, P=${ctx.raw.y.toFixed(1)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { title: { display: true, text: 'Momen Mu (kNm)' }, min: 0 },
                            y: { title: { display: true, text: 'Lực dọc Pu (kN)' } }
                        }
                    }
                });

                return () => { if (chartInstance.current) chartInstance.current.destroy(); };
            }, [interactionCurve, loads]);

            const handleLoadChange = (id, field, value) => {
                setLoads(loads.map(l => l.id === id ? { ...l, [field]: value } : l));
            };

            const renderCrossSection = () => {
                const maxDim = Math.max(geometry.B || geometry.D, geometry.H || geometry.D);
                const scale = 180 / maxDim;
                return (
                    <svg width="240" height="240" className="border bg-white mx-auto">
                        <g transform={`translate(120, 120) scale(${scale})`}>
                            {colType === 'rect' ? (
                                <rect x={-geometry.B/2} y={-geometry.H/2} width={geometry.B} height={geometry.H} fill="#f3f4f6" stroke="#374151" strokeWidth="2" />
                            ) : (
                                <circle cx="0" cy="0" r={geometry.D/2} fill="#f3f4f6" stroke="#374151" strokeWidth="2" />
                            )}
                            {barLayout.map((bar, i) => (
                                <circle key={i} cx={bar.x} cy={-bar.y} r={reinforcement.d_bar/2} fill="#dc2626" />
                            ))}
                        </g>
                    </svg>
                );
            };

            return (
                <div className="p-4 max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6 min-h-screen">
                    <div className="lg:col-span-5 flex flex-col gap-4">
                        <div className="bg-white p-4 rounded shadow">
                            <h1 className="text-xl font-bold text-blue-700 flex items-center gap-2">
                                <i data-lucide="activity"></i> ShortCol Web App
                            </h1>
                            <p className="text-xs text-gray-500 mt-1">Tính toán cột lệch tâm phẳng & Biểu đồ tương tác</p>
                        </div>
                        
                        <div className="bg-white rounded shadow flex-1 flex flex-col">
                            <div className="flex border-b">
                                <button onClick={() => setActiveTab('input')} className={`flex-1 py-3 text-sm font-semibold ${activeTab==='input'?'text-blue-600 border-b-2 border-blue-600':'text-gray-500'}`}>Thông số đầu vào</button>
                                <button onClick={() => setActiveTab('loads')} className={`flex-1 py-3 text-sm font-semibold ${activeTab==='loads'?'text-blue-600 border-b-2 border-blue-600':'text-gray-500'}`}>Tải trọng</button>
                            </div>
                            <div className="p-4 overflow-y-auto flex-1 h-0">
                                {activeTab === 'input' ? (
                                    <div className="space-y-4">
                                        <div className="grid grid-cols-2 gap-2">
                                            <button onClick={() => setColType('rect')} className={`p-2 border rounded text-sm ${colType==='rect'?'bg-blue-50 border-blue-500 text-blue-700':'text-gray-600'}`}>Cột Chữ nhật</button>
                                            <button onClick={() => setColType('circ')} className={`p-2 border rounded text-sm ${colType==='circ'?'bg-blue-50 border-blue-500 text-blue-700':'text-gray-600'}`}>Cột Tròn</button>
                                        </div>
                                        
                                        <div className="border p-3 rounded bg-gray-50">
                                            <p className="text-xs font-bold text-gray-500 mb-2 uppercase">Kích thước (mm)</p>
                                            <div className="grid grid-cols-2 gap-3">
                                                {colType === 'rect' ? (
                                                    <>
                                                        <div><label className="text-xs">Rộng B</label><input type="number" className="w-full border p-1 rounded" value={geometry.B} onChange={e=>setGeometry({...geometry, B:+e.target.value})}/></div>
                                                        <div><label className="text-xs">Cao H</label><input type="number" className="w-full border p-1 rounded" value={geometry.H} onChange={e=>setGeometry({...geometry, H:+e.target.value})}/></div>
                                                    </>
                                                ) : (
                                                    <div className="col-span-2"><label className="text-xs">Đường kính D</label><input type="number" className="w-full border p-1 rounded" value={geometry.D} onChange={e=>setGeometry({...geometry, D:+e.target.value})}/></div>
                                                )}
                                                <div><label className="text-xs">Lớp bảo vệ a</label><input type="number" className="w-full border p-1 rounded" value={geometry.Cover} onChange={e=>setGeometry({...geometry, Cover:+e.target.value})}/></div>
                                            </div>
                                        </div>

                                        <div className="border p-3 rounded bg-gray-50">
                                            <p className="text-xs font-bold text-gray-500 mb-2 uppercase">Vật liệu (MPa)</p>
                                            <div className="grid grid-cols-2 gap-3">
                                                <div><label className="text-xs">Bê tông Rb</label><input type="number" className="w-full border p-1 rounded" value={material.fck} onChange={e=>setMaterial({...material, fck:+e.target.value})}/></div>
                                                <div><label className="text-xs">Thép Rs</label><input type="number" className="w-full border p-1 rounded" value={material.fyk} onChange={e=>setMaterial({...material, fyk:+e.target.value})}/></div>
                                            </div>
                                        </div>

                                        <div className="border p-3 rounded bg-gray-50">
                                            <p className="text-xs font-bold text-gray-500 mb-2 uppercase">Cốt thép</p>
                                            <div className="grid grid-cols-3 gap-2">
                                                <div><label className="text-xs">Số thanh</label><input type="number" className="w-full border p-1 rounded" value={reinforcement.Nb} onChange={e=>setReinforcement({...reinforcement, Nb:+e.target.value})}/></div>
                                                <div><label className="text-xs">Đường kính</label><input type="number" className="w-full border p-1 rounded" value={reinforcement.d_bar} onChange={e=>setReinforcement({...reinforcement, d_bar:+e.target.value})}/></div>
                                                <div><label className="text-xs">As (mm2)</label><input type="number" className="w-full border p-1 rounded" value={reinforcement.As_bar} onChange={e=>setReinforcement({...reinforcement, As_bar:+e.target.value})}/></div>
                                            </div>
                                        </div>
                                        <div className="text-center pt-2">{renderCrossSection()}</div>
                                    </div>
                                ) : (
                                    <div className="space-y-2">
                                        <div className="flex justify-between"><span className="text-sm font-bold">Danh sách tải trọng</span><button onClick={()=>setLoads([...loads, {id: Date.now(), Mu:0, Pu:0, note:'New'}])} className="text-xs bg-blue-600 text-white px-2 py-1 rounded">Thêm</button></div>
                                        {loads.map((l, idx) => (
                                            <div key={l.id} className="flex gap-2 items-center border p-2 rounded bg-white">
                                                <span className="text-xs font-mono text-gray-400 w-4">{idx+1}</span>
                                                <input className="flex-1 text-sm border-b border-transparent focus:border-blue-500 outline-none" value={l.note} onChange={e=>handleLoadChange(l.id, 'note', e.target.value)} placeholder="Tên TH"/>
                                                <div className="w-16"><span className="text-[10px] text-gray-500 block">Mu</span><input type="number" className="w-full text-sm font-semibold" value={l.Mu} onChange={e=>handleLoadChange(l.id, 'Mu', +e.target.value)}/></div>
                                                <div className="w-16"><span className="text-[10px] text-gray-500 block">Pu</span><input type="number" className="w-full text-sm font-semibold" value={l.Pu} onChange={e=>handleLoadChange(l.id, 'Pu', +e.target.value)}/></div>
                                                <button onClick={()=>setLoads(loads.filter(x=>x.id!==l.id))} className="text-red-500 hover:bg-red-50 p-1 rounded">&times;</button>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="lg:col-span-7 flex flex-col gap-4">
                        <div className="bg-white p-4 rounded shadow h-[450px] relative">
                            <canvas ref={chartRef}></canvas>
                        </div>
                        <div className="bg-white p-4 rounded shadow flex-1 overflow-auto">
                            <h3 className="text-sm font-bold text-gray-700 mb-3">Kết quả kiểm tra</h3>
                            <table className="w-full text-sm text-left">
                                <thead className="bg-gray-100 text-gray-600">
                                    <tr>
                                        <th className="p-2">Tổ hợp</th>
                                        <th className="p-2 text-right">Mu</th>
                                        <th className="p-2 text-right">Pu</th>
                                        <th className="p-2 text-right">M_cap</th>
                                        <th className="p-2 text-right">P_cap</th>
                                        <th className="p-2 text-center">HS An toàn k</th>
                                        <th className="p-2 text-center">TT</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y">
                                    {loads.map(l => {
                                        const kVal = calculateSafetyFactorExact(l.Pu, l.Mu, interactionCurve);
                                        const k = parseFloat(kVal);
                                        const isSafe = k >= 1;
                                        const color = isSafe ? "text-green-600" : "text-red-600";
                                        const Mcap = isNaN(k) ? "-" : (Math.abs(l.Mu) * k).toFixed(1);
                                        const Pcap = isNaN(k) ? "-" : (l.Pu * k).toFixed(1);

                                        return (
                                            <tr key={l.id}>
                                                <td className="p-2 font-medium">{l.note}</td>
                                                <td className="p-2 text-right">{l.Mu}</td>
                                                <td className="p-2 text-right">{l.Pu}</td>
                                                <td className="p-2 text-right text-gray-400">{Mcap}</td>
                                                <td className="p-2 text-right text-gray-400">{Pcap}</td>
                                                <td className={`p-2 text-center font-bold ${color}`}>{kVal}</td>
                                                <td className="p-2 text-center">
                                                    {isNaN(k) ? "" : (isSafe ? <span className="px-2 py-0.5 bg-green-100 text-green-700 rounded text-xs">Đạt</span> : <span className="px-2 py-0.5 bg-red-100 text-red-700 rounded text-xs">Fail</span>)}
                                                </td>
                                            </tr>
                                        )
                                    })}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        setTimeout(() => window.lucide && window.lucide.createIcons(), 500);
    </script>
</body>
</html>