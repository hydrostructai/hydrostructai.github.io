<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShortCol 3D - Cột Lệch Tâm Xiên</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Plotly.js (Cho biểu đồ 3D) -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #f8fafc; }
        .tab-active { border-bottom: 2px solid #2563eb; color: #2563eb; font-weight: 600; }
        .tab-inactive { color: #6b7280; }
        .tab-inactive:hover { color: #374151; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .loading-spinner {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%;
            width: 30px; height: 30px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- 1. CORE MATH & UTILS ---

        // Tạo lưới sợi bê tông (Fiber Mesh)
        const generateConcreteFibers = (type, B, H, D) => {
            const fibers = [];
            const nx = 10; // Số chia theo phương X
            const ny = 10; // Số chia theo phương Y
            
            if (type === 'rect') {
                const dx = B / nx;
                const dy = H / ny;
                const dA = dx * dy;
                for (let i = 0; i < nx; i++) {
                    for (let j = 0; j < ny; j++) {
                        fibers.push({
                            x: -B/2 + (i + 0.5) * dx,
                            y: -H/2 + (j + 0.5) * dy,
                            dA: dA
                        });
                    }
                }
            } else {
                // Cột tròn: Chia rẻ quạt & bán kính
                const nr = 6;
                const ntheta = 12;
                const R = D/2;
                for (let i = 0; i < nr; i++) {
                    const r_inner = (i) * R / nr;
                    const r_outer = (i + 1) * R / nr;
                    const r_center = (r_inner + r_outer) / 2;
                    const dA = Math.PI * (r_outer**2 - r_inner**2) / ntheta;
                    
                    for (let j = 0; j < ntheta; j++) {
                        const theta = (j * 2 * Math.PI) / ntheta;
                        fibers.push({
                            x: r_center * Math.cos(theta),
                            y: r_center * Math.sin(theta),
                            dA: dA
                        });
                    }
                }
            }
            return fibers;
        };

        // --- 2. LOGIC CỐT THÉP (Inherited) ---
        const generateRectLayoutEqual = (B, H, Cover, Nb, As) => {
            const width = B - 2 * Cover;
            const height = H - 2 * Cover;
            if (Nb < 4) Nb = 4;
            if (Nb % 2 !== 0) Nb += 1;
            let Nb1 = Math.floor(((width) * (Nb + 2) + 2 * (height)) / 2 / (H + B - 4 * Cover));
            if (Nb1 < 2) Nb1 = 2;
            let Nbot = Nb1; let Ntop = Nb1;
            let Nside = (Nb - Nbot - Ntop) / 2 + 2; 
            if (!Number.isInteger(Nside) || Nside < 2) {
                 Nside = Math.floor((Nb - 4) / 2) + 2; 
                 const remainder = Nb - 2 * (Nside - 2);
                 Nbot = Math.floor(remainder / 2);
                 Ntop = remainder - Nbot;
            }
            const bars = [];
            for (let i = 0; i < Nbot; i++) bars.push({ x: -width/2 + (width / (Math.max(Nbot - 1, 1))) * i, y: -height/2, As: As });
            for (let i = 0; i < Ntop; i++) bars.push({ x: -width/2 + (width / (Math.max(Ntop - 1, 1))) * i, y: height/2, As: As });
            if (Nside > 2) {
                const sideSpacing = height / (Nside - 1);
                for (let i = 1; i < Nside - 1; i++) {
                    bars.push({ x: -width/2, y: -height/2 + sideSpacing * i, As: As });
                    bars.push({ x: width/2, y: -height/2 + sideSpacing * i, As: As });
                }
            }
            return bars;
        };

        const generateCircLayout = (D, Cover, Nb, As) => {
            const R_bars = D / 2 - Cover;
            const bars = [];
            if (Nb < 4) Nb = 4;
            for (let i = 0; i < Nb; i++) {
                const angle = (2 * Math.PI / Nb) * i;
                bars.push({ x: R_bars * Math.cos(angle), y: R_bars * Math.sin(angle), As: As });
            }
            return bars;
        };

        // --- 3. CORE TÍNH TOÁN 3D (BIAXIAL INTERACTION) ---
        
        const calculate3DSurface = (type, B, H, D, fck, fyk, bars) => {
            const points = [];
            const Es = 200000; 
            const e_cu = 0.003; 
            const Rb = fck; // Giả sử đã là Rb tính toán
            const Rs = fyk; 

            // Tạo lưới sợi bê tông 1 lần
            const concreteFibers = generateConcreteFibers(type, B, H, D);

            // Các biến quét để tạo mặt 3D
            // Quét góc nghiêng trục trung hòa (Neutral Axis Angle)
            const thetaSteps = 24; // 15 độ một bước (360/24)
            const cSteps = 15;     // Số bước chiều sâu vùng nén

            // Giới hạn max dimension để xác định range c
            const maxDim = type === 'rect' ? Math.sqrt(B*B + H*H) : D;
            
            // Loop Theta (Góc trục trung hòa)
            for (let t = 0; t < thetaSteps; t++) {
                const theta = (t * 2 * Math.PI) / thetaSteps;
                const cosT = Math.cos(theta);
                const sinT = Math.sin(theta);

                // Xác định miền biên cực hạn của tiết diện theo hướng theta
                // Để biết c chạy từ đâu đến đâu (d_min đến d_max)
                // Khoảng cách d = x*cos + y*sin
                let d_min = 99999, d_max = -99999;
                
                // Check corners/bounds
                const bounds = type === 'rect' 
                    ? [{x:-B/2,y:-H/2}, {x:B/2,y:-H/2}, {x:B/2,y:H/2}, {x:-B/2,y:H/2}] 
                    : [{x:-D/2,y:0}, {x:D/2,y:0}, {x:0,y:-D/2}, {x:0,y:D/2}]; // Sơ bộ
                
                if(type === 'circ') { d_min = -D/2; d_max = D/2; }
                else {
                    bounds.forEach(p => {
                        const d = p.x * cosT + p.y * sinT;
                        if(d < d_min) d_min = d;
                        if(d > d_max) d_max = d;
                    });
                }

                // Loop C (Chiều sâu trục trung hòa)
                // Chỉ quét vùng nén (c > 0) để vẽ biểu đồ tương tác chính
                // Quét c từ rất nhỏ (kéo nhiều) đến rất lớn (nén toàn bộ)
                const c_values = [];
                // Nén thuần túy (1 điểm duy nhất, không cần loop nhiều)
                // Các điểm trung gian
                for (let k = 0.1; k <= 1.5; k += 1.5/cSteps) {
                     // c tính từ mép chịu nén cực đại (d_max) đi vào
                     // Khoảng cách từ trục trung hòa đến gốc O là: dist_NA = d_max - c
                     // Nhưng c quy ước là chiều cao vùng nén.
                     c_values.push(k * maxDim);
                }

                c_values.forEach(c => {
                    let Nu = 0;
                    let Mux = 0;
                    let Muy = 0;

                    // Tính toán lực Bê tông (Tích phân thới)
                    // Strain tại điểm (x,y): e = e_cu * (dist_from_NA) / c
                    // dist_from_NA = (khoảng cách từ điểm đó đến mép nén cực hạn d_max) - (khoảng cách từ NA đến d_max = c) ? 
                    // Công thức chuẩn: e(x,y) = e_cu * ( (d_max - d(x,y)) / c - 1 ) ??
                    // Dễ hơn: Strain biến thiên tuyến tính. Tại d_max strain = e_cu. Tại (d_max - c) strain = 0.
                    // => strain = e_cu * (d_coord - (d_max - c)) / c  (với d_coord là tọa độ chiếu lên trục vuông góc NA)
                    // d_coord = x*cosT + y*sinT
                    
                    const NA_dist_from_origin = d_max - c;

                    concreteFibers.forEach(fib => {
                        const d_fib = fib.x * cosT + fib.y * sinT; // Khoảng cách chiếu
                        // Strain: Nén là dương
                        let strain = e_cu * (d_fib - NA_dist_from_origin) / c;
                        
                        // Stress block (Parabola-Rectangle hoặc Whitney đơn giản cho Fiber)
                        // Dùng mô hình giản đơn: if strain > 0: stress = Rb (nếu strain > e0...) 
                        // Dùng Whitney cho đơn giản:
                        // Vùng nén hiệu quả a = 0.8 * c
                        // Điều kiện fiber nằm trong vùng nén hiệu quả:
                        // d_fib > d_max - 0.8*c
                        
                        // Để chính xác hơn với Fiber, dùng biểu đồ E-Curve của bê tông hoặc Step function
                        // Step function (Whitney):
                        if (d_fib > (d_max - 0.8 * c)) {
                            Nu += Rb * fib.dA;
                            Mux += (Rb * fib.dA) * fib.y; // Momen quanh trục X = Lực * tay đòn Y
                            Muy += (Rb * fib.dA) * fib.x; // Momen quanh trục Y = Lực * tay đòn X
                        }
                    });

                    // Tính toán lực Cốt thép
                    bars.forEach(bar => {
                        const d_bar = bar.x * cosT + bar.y * sinT;
                        let strain = 0;
                        if (c === 0) strain = -0.01;
                        else strain = e_cu * (d_bar - NA_dist_from_origin) / c;

                        // Hooke's law
                        let stress = strain * Es;
                        if (stress > Rs) stress = Rs;
                        if (stress < -Rs) stress = -Rs;

                        const Force = stress * bar.As;
                        Nu += Force;
                        Mux += Force * bar.y;
                        Muy += Force * bar.x;
                    });
                    
                    // Convert units: N -> kN, Nmm -> kNm
                    points.push({
                        x: Mux / 1e6,
                        y: Muy / 1e6,
                        z: Nu / 1e3
                    });
                });
            }

            // Thêm điểm Nén thuần túy (P0) và Kéo thuần túy (P_t) để đóng kín hình bao
            // (Tính sơ bộ)
            const Ag = type==='rect' ? B*H : Math.PI*D*D/4;
            const Ast = bars.reduce((s,b)=>s+b.As,0);
            const Po_comp = (0.85 * Rb * (Ag - Ast) + Rs * Ast)/1000;
            const Po_tens = (-Rs * Ast)/1000;
            
            // Thêm đỉnh nén vào tất cả các góc quét để tạo chóp đẹp
            for(let t=0; t<thetaSteps; t++) points.push({x:0, y:0, z: Po_comp});
            // Thêm đáy kéo
            for(let t=0; t<thetaSteps; t++) points.push({x:0, y:0, z: Po_tens});

            return points;
        };

        // --- 4. SAFETY FACTOR (3D RAY INTERSECTION) ---
        // Tìm giao điểm của tia vector tải trọng với đám mây điểm (Convex Hull xấp xỉ)
        const calculateSafetyFactor3D = (Pu, Mux, Muy, surfacePoints) => {
            const distLoad = Math.sqrt(Pu*Pu + Mux*Mux + Muy*Muy);
            if (distLoad < 0.1) return 999;

            // Tìm điểm trên mặt tương tác nằm trên cùng phương vector
            // Vector hướng n = (Mux, Muy, Pu) normalized
            // Cách đơn giản nhất: Tìm điểm trong surfacePoints có (Mux/P, Muy/P) gần nhất? 
            // Không, vì P thay đổi.
            // Dùng thuật toán Nearest Neighbor trên tọa độ cầu hoặc so sánh tỷ lệ.
            
            let maxK = 0;
            // Duyệt qua tất cả tam giác tạo bởi điểm (Simplified: Duyệt điểm)
            // Vì surfacePoints là đám mây dày đặc, ta tìm điểm có vector gần song song nhất
            // Cos(angle) = (v1 . v2) / (|v1| |v2|)
            
            // Lọc các điểm có cùng "Octant" (Dấu)
            // Tuy nhiên P-Mx-My có thể âm dương.
            
            let bestDot = -1;
            let bestPoint = null;

            for (let p of surfacePoints) {
                const distP = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
                if (distP < 1) continue;
                
                // Dot product vector hướng
                const dot = (p.x * Mux + p.y * Muy + p.z * Pu) / (distP * distLoad);
                
                // Nếu vector song song (dot ~ 1)
                if (dot > bestDot) {
                    bestDot = dot;
                    bestPoint = p;
                }
            }

            // Nếu tìm thấy điểm tương đồng hướng cao (>0.99), dùng tỷ lệ khoảng cách
            // Nếu không (do lưới thưa), ta có thể nội suy. 
            // Với app này, bestDot thường > 0.995 do lưới khá dày.
            
            if (bestPoint && bestDot > 0.98) {
                const distCap = Math.sqrt(bestPoint.x**2 + bestPoint.y**2 + bestPoint.z**2);
                // Hiệu chỉnh 1 chút do lệch góc: K = (Projection of Cap on LoadVector) / LoadMag
                // K = (distCap * dot) / distLoad
                return (distCap / distLoad).toFixed(2);
            }
            
            return "N/A";
        };


        // --- COMPONENT CHÍNH ---

        const App = () => {
            const [activeTab, setActiveTab] = useState('input');
            const [isCalculating, setIsCalculating] = useState(false);
            const [colType, setColType] = useState('rect'); 
            
            // State Inputs
            const [material, setMaterial] = useState({ fck: 14.5, fyk: 280 });
            const [geometry, setGeometry] = useState({ B: 300, H: 400, D: 400, Cover: 30 });
            const [reinforcement, setReinforcement] = useState({ Nb: 8, d_bar: 20, As_bar: 314 });
            
            // Tải trọng (Thêm Muy)
            const [loads, setLoads] = useState([
                { id: 1, Pu: 800, Mux: 60, Muy: 20, note: "TH1: Tĩnh+Hoạt" },
                { id: 2, Pu: 400, Mux: 120, Muy: 80, note: "TH2: Gió chéo" }
            ]);

            // Calculated Data
            const [barLayout, setBarLayout] = useState([]);
            const [surfacePoints, setSurfacePoints] = useState([]);
            
            const chartDivRef = useRef(null);

            // 1. Update Bar Layout khi input đổi
            useEffect(() => {
                let bars = [];
                const As = reinforcement.As_bar;
                if (colType === 'rect') {
                    bars = generateRectLayoutEqual(geometry.B, geometry.H, geometry.Cover, reinforcement.Nb, As);
                } else {
                    bars = generateCircLayout(geometry.D, geometry.Cover, reinforcement.Nb, As);
                }
                setBarLayout(bars);
            }, [colType, geometry, reinforcement]);

            // 2. Tính toán Surface 3D (Debounced hoặc Manual Trigger để tránh lag)
            // Tự động tính khi input dừng thay đổi 500ms
            useEffect(() => {
                const timer = setTimeout(() => {
                    if (barLayout.length > 0) {
                        setIsCalculating(true);
                        // Cho UI render loading trước khi tính nặng
                        requestAnimationFrame(() => {
                            const points = calculate3DSurface(
                                colType, geometry.B, geometry.H, geometry.D, 
                                material.fck, material.fyk, barLayout
                            );
                            setSurfacePoints(points);
                            setIsCalculating(false);
                        });
                    }
                }, 500);
                return () => clearTimeout(timer);
            }, [barLayout, material, geometry.B, geometry.H, geometry.D, colType]);

            // 3. Vẽ biểu đồ Plotly
            useEffect(() => {
                if (!surfacePoints.length || !chartDivRef.current) return;

                // Tách tọa độ Surface
                const xS = surfacePoints.map(p => p.x); // Mux
                const yS = surfacePoints.map(p => p.y); // Muy
                const zS = surfacePoints.map(p => p.z); // Pu

                // Dữ liệu Points Tải trọng
                const xL = loads.map(l => l.Mux);
                const yL = loads.map(l => l.Muy);
                const zL = loads.map(l => l.Pu);
                const textL = loads.map(l => l.note);
                const colorL = loads.map((l) => {
                    const k = calculateSafetyFactor3D(l.Pu, l.Mux, l.Muy, surfacePoints);
                    return (k >= 1 && k !== "N/A") ? 'green' : 'red';
                });

                // Đường gióng (Lines from origin to load points)
                const lineTraces = [];
                loads.forEach((l, idx) => {
                     const k = calculateSafetyFactor3D(l.Pu, l.Mux, l.Muy, surfacePoints);
                     if(k !== "N/A") {
                         const valK = parseFloat(k);
                         lineTraces.push({
                            type: 'scatter3d',
                            mode: 'lines',
                            x: [0, l.Mux * Math.max(1.2, valK)],
                            y: [0, l.Muy * Math.max(1.2, valK)],
                            z: [0, l.Pu * Math.max(1.2, valK)],
                            line: { color: valK >= 1 ? 'green' : 'red', width: 3, dash: 'dot' },
                            showlegend: false,
                            hoverinfo: 'none'
                         });
                     }
                });

                const data = [
                    // Surface (Mesh)
                    {
                        type: 'mesh3d',
                        x: xS, y: yS, z: zS,
                        opacity: 0.3,
                        color: '#3b82f6',
                        alphahull: 0, // Convex hull visualization
                        name: 'Biểu đồ tương tác',
                        hoverinfo: 'none' // Giảm lag
                    },
                    // Load Points
                    {
                        type: 'scatter3d',
                        mode: 'markers+text',
                        x: xL, y: yL, z: zL,
                        marker: { size: 5, color: colorL },
                        text: textL,
                        textposition: 'top center',
                        name: 'Tải trọng'
                    },
                    ...lineTraces
                ];

                const layout = {
                    title: 'Biểu đồ tương tác không gian (Pu - Mux - Muy)',
                    scene: {
                        xaxis: { title: 'Mux (kNm)' },
                        yaxis: { title: 'Muy (kNm)' },
                        zaxis: { title: 'Pu (kN)' },
                        camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
                    },
                    margin: { l: 0, r: 0, b: 0, t: 30 },
                    showlegend: false,
                    height: 500,
                };

                Plotly.newPlot(chartDivRef.current, data, layout, {responsive: true, displayModeBar: false});

            }, [surfacePoints, loads]);


            // Helper Handlers
            const handleLoadChange = (id, field, value) => {
                setLoads(loads.map(l => l.id === id ? { ...l, [field]: value } : l));
            };

            const renderCrossSection = () => {
                const maxDim = Math.max(geometry.B || geometry.D, geometry.H || geometry.D);
                const scale = 160 / maxDim;
                return (
                    <svg width="200" height="200" className="border bg-white mx-auto shadow-sm">
                        <g transform={`translate(100, 100) scale(${scale})`}>
                            {colType === 'rect' ? (
                                <rect x={-geometry.B/2} y={-geometry.H/2} width={geometry.B} height={geometry.H} fill="#e5e7eb" stroke="#374151" strokeWidth="2" />
                            ) : (
                                <circle cx="0" cy="0" r={geometry.D/2} fill="#e5e7eb" stroke="#374151" strokeWidth="2" />
                            )}
                            {/* Trục toạ độ */}
                            <line x1="-1000" y1="0" x2="1000" y2="0" stroke="#9ca3af" strokeWidth="1" strokeDasharray="5,5" />
                            <line x1="0" y1="-1000" x2="0" y2="1000" stroke="#9ca3af" strokeWidth="1" strokeDasharray="5,5" />
                            {/* Rebars */}
                            {barLayout.map((bar, i) => (
                                <circle key={i} cx={bar.x} cy={-bar.y} r={reinforcement.d_bar/2} fill="#dc2626" />
                            ))}
                        </g>
                        <text x="10" y="190" fontSize="10" fill="#666">X: Mux axis, Y: Muy axis</text>
                    </svg>
                );
            };

            return (
                <div className="p-4 max-w-7xl mx-auto min-h-screen flex flex-col gap-4">
                    {/* Header */}
                    <div className="bg-white p-4 rounded-lg shadow flex justify-between items-center">
                        <div>
                            <h1 className="text-xl font-bold text-blue-700 flex items-center gap-2">
                                <i data-lucide="box-select"></i> ShortCol 3D
                            </h1>
                            <p className="text-sm text-gray-500">Tính toán cột lệch tâm xiên (Biaxial Bending) & Biểu đồ tương tác không gian</p>
                        </div>
                        {isCalculating && (
                            <div className="flex items-center gap-2 text-blue-600 text-sm font-semibold">
                                <div className="loading-spinner w-4 h-4 border-2"></div>
                                Đang tính toán 3D...
                            </div>
                        )}
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-12 gap-6 flex-1">
                        {/* LEFT: INPUT */}
                        <div className="lg:col-span-4 flex flex-col gap-4">
                            <div className="bg-white rounded-lg shadow overflow-hidden flex-1">
                                <div className="flex border-b">
                                    <button onClick={() => setActiveTab('input')} className={`flex-1 py-3 text-sm font-semibold ${activeTab==='input'?'text-blue-600 border-b-2 border-blue-600 bg-blue-50':'text-gray-500 hover:bg-gray-50'}`}>Thông số</button>
                                    <button onClick={() => setActiveTab('loads')} className={`flex-1 py-3 text-sm font-semibold ${activeTab==='loads'?'text-blue-600 border-b-2 border-blue-600 bg-blue-50':'text-gray-500 hover:bg-gray-50'}`}>Tải trọng</button>
                                </div>
                                
                                <div className="p-4 h-[500px] overflow-y-auto">
                                    {activeTab === 'input' ? (
                                        <div className="space-y-5">
                                            {/* Type */}
                                            <div>
                                                <label className="text-xs font-bold text-gray-500 uppercase">Loại tiết diện</label>
                                                <div className="flex gap-2 mt-1">
                                                    <button onClick={() => setColType('rect')} className={`flex-1 py-2 text-sm border rounded ${colType==='rect'?'bg-blue-100 border-blue-500 text-blue-800 font-bold':'bg-white text-gray-600'}`}>Chữ nhật</button>
                                                    <button onClick={() => setColType('circ')} className={`flex-1 py-2 text-sm border rounded ${colType==='circ'?'bg-blue-100 border-blue-500 text-blue-800 font-bold':'bg-white text-gray-600'}`}>Tròn</button>
                                                </div>
                                            </div>

                                            {/* Geometry */}
                                            <div className="p-3 bg-gray-50 rounded border">
                                                <label className="text-xs font-bold text-gray-500 uppercase mb-2 block">Kích thước (mm)</label>
                                                <div className="grid grid-cols-2 gap-3">
                                                    {colType === 'rect' ? (
                                                        <>
                                                            <div><span className="text-xs text-gray-500">Rộng B</span><input type="number" value={geometry.B} onChange={e=>setGeometry({...geometry, B:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                            <div><span className="text-xs text-gray-500">Cao H</span><input type="number" value={geometry.H} onChange={e=>setGeometry({...geometry, H:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                        </>
                                                    ) : (
                                                        <div className="col-span-2"><span className="text-xs text-gray-500">Đường kính D</span><input type="number" value={geometry.D} onChange={e=>setGeometry({...geometry, D:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                    )}
                                                    <div><span className="text-xs text-gray-500">Lớp bảo vệ a</span><input type="number" value={geometry.Cover} onChange={e=>setGeometry({...geometry, Cover:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                </div>
                                            </div>

                                            {/* Material */}
                                            <div className="p-3 bg-gray-50 rounded border">
                                                <label className="text-xs font-bold text-gray-500 uppercase mb-2 block">Vật liệu (MPa)</label>
                                                <div className="grid grid-cols-2 gap-3">
                                                    <div><span className="text-xs text-gray-500">Bê tông Rb</span><input type="number" value={material.fck} onChange={e=>setMaterial({...material, fck:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                    <div><span className="text-xs text-gray-500">Cốt thép Rs</span><input type="number" value={material.fyk} onChange={e=>setMaterial({...material, fyk:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                </div>
                                            </div>

                                            {/* Rebar */}
                                            <div className="p-3 bg-gray-50 rounded border">
                                                <label className="text-xs font-bold text-gray-500 uppercase mb-2 block">Cốt thép</label>
                                                <div className="grid grid-cols-3 gap-2">
                                                    <div><span className="text-xs text-gray-500">Số thanh</span><input type="number" value={reinforcement.Nb} onChange={e=>setReinforcement({...reinforcement, Nb:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                    <div><span className="text-xs text-gray-500">Đk (mm)</span><input type="number" value={reinforcement.d_bar} onChange={e=>setReinforcement({...reinforcement, d_bar:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                    <div><span className="text-xs text-gray-500">As (mm2)</span><input type="number" value={reinforcement.As_bar} onChange={e=>setReinforcement({...reinforcement, As_bar:+e.target.value})} className="w-full border rounded p-1.5 text-sm"/></div>
                                                </div>
                                            </div>

                                            {/* Preview */}
                                            <div className="text-center pt-2">
                                                {renderCrossSection()}
                                                <p className="text-xs text-gray-400 mt-1">Trục X: Momen quanh trục X (Mux) <br/> Trục Y: Momen quanh trục Y (Muy)</p>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="space-y-3">
                                            <div className="flex justify-between items-center">
                                                <span className="text-sm font-bold text-gray-700">Tổ hợp nội lực</span>
                                                <button onClick={()=>setLoads([...loads, {id: Date.now(), Pu:0, Mux:0, Muy:0, note:'Mới'}])} className="text-xs bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700 font-bold">+ Thêm</button>
                                            </div>
                                            {loads.map((l, idx) => (
                                                <div key={l.id} className="border p-3 rounded bg-white shadow-sm relative group">
                                                    <div className="flex justify-between mb-2">
                                                        <input className="font-bold text-sm text-blue-700 outline-none w-2/3" value={l.note} onChange={e=>handleLoadChange(l.id, 'note', e.target.value)} />
                                                        <button onClick={()=>setLoads(loads.filter(x=>x.id!==l.id))} className="text-red-400 hover:text-red-600 text-xs font-bold px-2">Xóa</button>
                                                    </div>
                                                    <div className="grid grid-cols-3 gap-2">
                                                        <div><span className="text-[10px] text-gray-500 font-bold block">Pu (kN)</span><input type="number" className="w-full border rounded p-1 text-sm bg-gray-50" value={l.Pu} onChange={e=>handleLoadChange(l.id, 'Pu', +e.target.value)}/></div>
                                                        <div><span className="text-[10px] text-gray-500 font-bold block">Mux (kNm)</span><input type="number" className="w-full border rounded p-1 text-sm bg-gray-50" value={l.Mux} onChange={e=>handleLoadChange(l.id, 'Mux', +e.target.value)}/></div>
                                                        <div><span className="text-[10px] text-gray-500 font-bold block">Muy (kNm)</span><input type="number" className="w-full border rounded p-1 text-sm bg-gray-50" value={l.Muy} onChange={e=>handleLoadChange(l.id, 'Muy', +e.target.value)}/></div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* RIGHT: CHART & RESULT */}
                        <div className="lg:col-span-8 flex flex-col gap-4">
                            {/* 3D Chart Container */}
                            <div className="bg-white p-2 rounded-lg shadow border h-[500px] relative">
                                <div ref={chartDivRef} className="w-full h-full"></div>
                                <div className="absolute top-2 left-2 bg-white/80 p-2 rounded text-xs text-gray-500 pointer-events-none">
                                    Xoay chuột để xem 3D • Cuộn để Zoom
                                </div>
                            </div>

                            {/* Result Table */}
                            <div className="bg-white p-4 rounded-lg shadow flex-1 overflow-x-auto">
                                <h3 className="text-sm font-bold text-gray-700 mb-3 border-b pb-2 flex items-center gap-2">
                                    <i data-lucide="calculator"></i> Kết quả kiểm tra ổn định tổng hợp
                                </h3>
                                <table className="w-full text-sm text-left">
                                    <thead className="bg-gray-100 text-gray-600 font-bold">
                                        <tr>
                                            <th className="p-3 rounded-tl-lg">Tổ hợp</th>
                                            <th className="p-3 text-right">Pu (kN)</th>
                                            <th className="p-3 text-right">Mux (kNm)</th>
                                            <th className="p-3 text-right">Muy (kNm)</th>
                                            <th className="p-3 text-center">HS An toàn (k)</th>
                                            <th className="p-3 text-center rounded-tr-lg">Đánh giá</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-100">
                                        {loads.map(l => {
                                            const kVal = calculateSafetyFactor3D(l.Pu, l.Mux, l.Muy, surfacePoints);
                                            const k = parseFloat(kVal);
                                            const isSafe = k >= 1;
                                            const statusClass = isSafe ? "bg-green-100 text-green-700 border-green-200" : "bg-red-100 text-red-700 border-red-200";
                                            
                                            return (
                                                <tr key={l.id} className="hover:bg-gray-50">
                                                    <td className="p-3 font-medium text-blue-900">{l.note}</td>
                                                    <td className="p-3 text-right">{l.Pu}</td>
                                                    <td className="p-3 text-right">{l.Mux}</td>
                                                    <td className="p-3 text-right">{l.Muy}</td>
                                                    <td className="p-3 text-center font-bold text-gray-800">{kVal}</td>
                                                    <td className="p-3 text-center">
                                                        {isNaN(k) ? <span className="text-gray-400">-</span> : 
                                                            <span className={`px-3 py-1 rounded-full text-xs font-bold border ${statusClass}`}>
                                                                {isSafe ? "ĐẠT" : "KHÔNG ĐẠT"}
                                                            </span>
                                                        }
                                                    </td>
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                                <div className="mt-2 text-xs text-gray-500 italic">
                                    * Hệ số k = (Khoảng cách từ gốc đến biên chịu lực) / (Khoảng cách từ gốc đến điểm tải trọng). <br/>
                                    * Mux: Momen uốn quanh trục X (gây nén vùng Y). Muy: Momen uốn quanh trục Y (gây nén vùng X).
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        
        // Init Icons
        setTimeout(() => {
            if(window.lucide) lucide.createIcons();
        }, 1000);
    </script>
</body>
</html>