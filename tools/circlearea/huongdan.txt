Dưới đây là mã cho các tệp tiếp theo.

Hai tệp đầu tiên là các thư viện bên ngoài. Bạn **không cần gõ lại** mã này; bạn chỉ cần **tải các tệp này** và lưu chúng vào thư mục `lib/` của mình.

-----

### 1\. `lib/p5.min.js` (Chỉ cần Tải về)

  * **Mục đích:** Thư viện đồ họa p5.js.
  * **Hành động:** Truy cập [https://p5js.org/download/](https://p5js.org/download/) và tải về tệp `p5.min.js`.
  * **Mã (Không cần hiển thị):** *Đây là một tệp thư viện rất lớn, đã được thu gọn (minified).*

-----

### 2\. `lib/numeric.min.js` (Chỉ cần Tải về)

  * **Mục đích:** Thư viện toán học `numeric.js` để giải hệ phương trình.
  * **Hành động:** Tải tệp `numeric.min.js` từ nguồn (ví dụ: tìm "numeric.js github" và tải tệp `numeric.min.js` từ thư mục `lib/` của dự án đó).
  * **Mã (Không cần hiển thị):** *Đây cũng là một tệp thư viện đã được thu gọn.*

-----

### 3\. `js/solver.js` (Mã Lõi Toán học)

Đây là tệp quan trọng nhất, nơi chúng ta định nghĩa hệ 6 phương trình và sử dụng `numeric.js` để tìm nghiệm.

```javascript
/* * ========================================================
 * js/solver.js
 * Định nghĩa và giải hệ phương trình phi tuyến
 * ========================================================
 */

/**
 * Hàm mục tiêu (Objective Function) cho thuật toán tối ưu hóa.
 * numeric.js sẽ cố gắng tìm vector X để hàm này trả về giá trị nhỏ nhất (gần 0).
 *
 * @param {Array} X Vector 6 ẩn số: [xc, yc, R, xf, xg, xh]
 * @returns {number} Tổng bình phương của 6 hàm lỗi (Sum of Squared Errors)
 */
function objectiveFunction(X) {
    // Giải nén vector 6 ẩn số
    const [xc, yc, R, xf, xg, xh] = X;

    // --- Tính 6 giá trị lỗi (Errors) ---
    // Mục tiêu là làm cho cả 6 lỗi này = 0

    // Lỗi 1, 2, 3: Khoảng cách từ tâm (xc, yc) đến điểm tiếp xúc
    // phải bằng bán kính R.
    // Lỗi = (Khoảng cách tính được) - R
    const e1 = Math.sqrt(Math.pow(xc - xf, 2) + Math.pow(yc - f(xf), 2)) - R;
    const e2 = Math.sqrt(Math.pow(xc - xg, 2) + Math.pow(yc - g(xg), 2)) - R;
    const e3 = Math.sqrt(Math.pow(xc - xh, 2) + Math.pow(yc - h(xh), 2)) - R;

    // Lỗi 4, 5, 6: Điều kiện pháp tuyến (Normal condition)
    // Pháp tuyến của đường cong tại điểm tiếp xúc phải đi qua tâm (xc, yc).
    // Phương trình pháp tuyến: (Y - y) = (-1 / m) * (X - x)
    // Sắp xếp lại: (Y - y) * m + (X - x) = 0
    // (trong đó m là đạo hàm f'(x), g'(x), h'(x))
    
    // Xử lý trường hợp f_prime(xf) = 0 (pháp tuyến thẳng đứng)
    const e4 = (yc - f(xf)) * f_prime(xf) + (xc - xf);
    
    // Xử lý trường hợp g_prime(xg) = 0 (mặc dù e^x không bao giờ bằng 0)
    const e5 = (yc - g(xg)) * g_prime(xg) + (xc - xg);

    // Xử lý trường hợp h_prime(xh) = 0 (khi cos(x) = 0)
    const e6 = (yc - h(xh)) * h_prime(xh) + (xc - xh);

    // Trả về tổng bình phương của các lỗi.
    // Thuật toán sẽ cố gắng tối thiểu hóa giá trị này về 0.
    return (
        Math.pow(e1, 2) +
        Math.pow(e2, 2) +
        Math.pow(e3, 2) +
        Math.pow(e4, 2) +
        Math.pow(e5, 2) +
        Math.pow(e6, 2)
    );
}

/**
 * Hàm chính để chạy thuật toán giải
 * @returns {object} Một đối tượng chứa các giá trị đã giải: {xc, yc, R, xf, xg, xh}
 */
function solveForCircle() {
    console.log("Bắt đầu giải hệ phương trình...");
    console.log("Giá trị ước lượng ban đầu:", INITIAL_GUESS);

    // Gọi hàm `uncmin` (Unconstrained Minimization) của numeric.js
    // Nó nhận hàm mục tiêu và giá trị ước lượng ban đầu.
    // Tùy chọn {tol: 1e-10, maxiter: 2000} để tăng độ chính xác và số lần lặp
    const solution = numeric.uncmin(objectiveFunction, INITIAL_GUESS, 1e-10, null, 2000);

    // `solution.solution` là vector 6 phần tử kết quả
    const [xc, yc, R, xf, xg, xh] = solution.solution;

    console.log("Đã tìm thấy nghiệm:", solution.solution);
    console.log("Giá trị hàm lỗi cuối cùng:", solution.f); // Phải rất gần 0

    // Trả về một đối tượng có tên rõ ràng
    return {
        xc: xc,
        yc: yc,
        R: R,
        area: Math.PI * Math.pow(R, 2),
        touchPoints: {
            f: { x: xf, y: f(xf) },
            g: { x: xg, y: g(xg) },
            h: { x: xh, y: h(xh) },
        },
    };
}
```

-----

Bây giờ chúng ta đã có tất cả các thư viện và logic tính toán, tệp cuối cùng là `js/sketch.js` để **vẽ** mọi thứ lên màn hình bằng p5.js.

### 4\. `js/sketch.js` (Mã Lõi Đồ họa)

```javascript
/* * ========================================================
 * js/sketch.js
 * Sử dụng p5.js để vẽ biểu đồ và kết quả
 * ========================================================
 */

// Biến toàn cục để lưu trữ kết quả
let solution;
let mapping; // Đối tượng để lưu các hàm ánh xạ

// Hàm setup() của p5.js chạy một lần khi tải trang
function setup() {
    // 1. Tạo canvas và đặt nó vào div 'canvas-container'
    let canvas = createCanvas(GRAPH_CONFIG.canvasWidth, GRAPH_CONFIG.canvasHeight);
    canvas.parent('canvas-container');

    // 2. Tạo các hàm ánh xạ tọa độ
    // mapX: Chuyển tọa độ X toán học sang pixel X của canvas
    // mapY: Chuyển tọa độ Y toán học sang pixel Y của canvas (lưu ý Y bị đảo ngược)
    mapping = {
        mapX: (x) => map(x, GRAPH_CONFIG.xMin, GRAPH_CONFIG.xMax, 0, width),
        mapY: (y) => map(y, GRAPH_CONFIG.yMin, GRAPH_CONFIG.yMax, height, 0),
    };

    // 3. Giải hệ phương trình (chỉ chạy một lần)
    solution = solveForCircle();

    // 4. Hiển thị kết quả lên HTML
    displayResults(solution);

    // 5. Ngừng lặp (vì đây là biểu đồ tĩnh)
    noLoop();
}

// Hàm draw() của p5.js chạy sau setup()
function draw() {
    background(255); // Nền trắng

    // Vẽ trục tọa độ
    drawAxes();

    // Vẽ 3 hàm số
    drawFunction(f, GRAPH_CONFIG.colors.f, 2); // Đường f (đỏ), đậm 2px
    drawFunction(g, GRAPH_CONFIG.colors.g, 2); // Đường g (tím), đậm 2px
    drawFunction(h, GRAPH_CONFIG.colors.h, 2); // Đường h (xanh), đậm 2px

    // Vẽ hình tròn kết quả
    if (solution) {
        drawSolutionCircle(solution);
    }
}

/**
 * Hiển thị kết quả (tâm, bán kính, diện tích) ra vùng HTML #results
 */
function displayResults(sol) {
    const resultsDiv = select('#results');
    
    // Xóa thông báo "Đang tính toán..."
    resultsDiv.html('<h3>Kết quả Tính toán</h3>');

    // Định dạng số (làm tròn 4 chữ số thập phân)
    const format = (num) => num.toFixed(4);

    resultsDiv.html(
        `<h3>Kết quả Tính toán</h3>
         <p>Tâm (xc, yc): <br><span>(${format(sol.xc)}, ${format(sol.yc)})</span></p>
         <p>Bán kính (R): <br><span>${format(sol.R)}</span></p>
         <p>Diện tích (πR²): <br><span>${format(sol.area)}</span></p>
         <hr>
         <p>Tiếp điểm f(x): <br><span>(${format(sol.touchPoints.f.x)}, ${format(sol.touchPoints.f.y)})</span></p>
         <p>Tiếp điểm g(x): <br><span>(${format(sol.touchPoints.g.x)}, ${format(sol.touchPoints.g.y)})</span></p>
         <p>Tiếp điểm h(x): <br><span>(${format(sol.touchPoints.h.x)}, ${format(sol.touchPoints.h.y)})</span></p>
        `,
        true // Cho phép chèn HTML
    );
}

/**
 * Vẽ trục X và Y
 */
function drawAxes() {
    const { mapX, mapY } = mapping;
    stroke(GRAPH_CONFIG.colors.axis);
    strokeWeight(1.5);

    // Trục X (tại y=0)
    line(mapX(GRAPH_CONFIG.xMin), mapY(0), mapX(GRAPH_CONFIG.xMax), mapY(0));
    // Trục Y (tại x=0)
    line(mapX(0), mapY(GRAPH_CONFIG.yMin), mapX(0), mapY(GRAPH_CONFIG.yMax));

    // Thêm các vạch chia
    strokeWeight(1);
    textAlign(CENTER, CENTER);
    fill(GRAPH_CONFIG.colors.axis);
    
    for (let x = Math.ceil(GRAPH_CONFIG.xMin); x < GRAPH_CONFIG.xMax; x++) {
        if (x === 0) continue;
        line(mapX(x), mapY(0.1), mapX(x), mapY(-0.1));
        text(x, mapX(x), mapY(-0.3));
    }
    for (let y = Math.ceil(GRAPH_CONFIG.yMin); y < GRAPH_CONFIG.yMax; y++) {
        if (y === 0) continue;
        line(mapX(0.1), mapY(y), mapX(-0.1), mapY(y));
        text(y, mapX(-0.2), mapY(y));
    }
}

/**
 * Hàm trợ giúp để vẽ một hàm số y = func(x)
 * @param {function} func Hàm toán học (ví dụ: f, g, h)
 * @param {string} color Màu (hex)
 * @param {number} weight Độ dày nét vẽ
 */
function drawFunction(func, color, weight) {
    const { mapX, mapY } = mapping;
    noFill();
    stroke(color);
    strokeWeight(weight);
    
    beginShape();
    // Vẽ với độ phân giải cao (nhiều điểm ảnh)
    for (let px = 0; px <= width; px += 1) {
        // Chuyển đổi pixel X ngược lại tọa độ toán học x
        let x = map(px, 0, width, GRAPH_CONFIG.xMin, GRAPH_CONFIG.xMax);
        let y = func(x);

        // Chuyển (x, y) toán học sang (px, py)
        vertex(px, mapY(y));
    }
    endShape();
}

/**
 * Vẽ hình tròn giải pháp
 */
function drawSolutionCircle(sol) {
    const { mapX, mapY } = mapping;
    
    // Ánh xạ tâm (xc, yc) sang pixel
    const px_c = mapX(sol.xc);
    const py_c = mapY(sol.yc);
    
    // Tính bán kính (R) bằng pixel
    // Chúng ta phải tính toán dựa trên tỷ lệ pixel/đơn vị
    // (Giả sử tỷ lệ x và y là như nhau, nếu không vòng tròn sẽ là hình elip)
    const pixelPerUnitX = width / (GRAPH_CONFIG.xMax - GRAPH_CONFIG.xMin);
    const R_pixel = sol.R * pixelPerUnitX;
    
    // Vẽ hình tròn
    fill(GRAPH_CONFIG.colors.circle + 'AA'); // Màu vàng với độ trong 80% (AA)
    strokeWeight(2);
    stroke(0); // Viền đen
    
    circle(px_c, py_c, R_pixel * 2); // p5.js dùng đường kính
    
    // Thêm dấu '?' ở tâm
    fill(0);
    noStroke();
    textAlign(CENTER, CENTER);
    textSize(32);
    text('?', px_c, py_c);
}
```

-----

Như vậy là bạn đã có tất cả các tệp cần thiết. Giờ bạn chỉ cần mở `index.html` trong trình duyệt của mình (hoặc chạy một máy chủ web cục bộ) để xem kết quả.